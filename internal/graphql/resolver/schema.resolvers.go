package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.50

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"

	graphql1 "github.com/Lux00000/post-and-comments/internal/graphql/gen"
	"github.com/Lux00000/post-and-comments/internal/graphql/gen/model"
	"github.com/Lux00000/post-and-comments/internal/models"
)

// CreatePost is the resolver for the CreatePost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, authorID string, allowComments bool) (*model.Post, error) {
	intID, err := strconv.Atoi(authorID)
	if err != nil {
		return nil, err
	}
	newPost, err := r.PostsService.CreatePost(models.Post{
		Title:         title,
		Content:       content,
		AuthorId:      intID,
		AllowComments: allowComments,
	})
	if err != nil {
		return nil, err
	}
	mappedPost := model.Post{
		ID:            strconv.Itoa(newPost.ID),
		Title:         newPost.Title,
		Content:       newPost.Content,
		AuthorID:      strconv.Itoa(newPost.AuthorId),
		AllowComments: newPost.AllowComments,
	}

	return &mappedPost, nil
}

// CreateComment is the resolver for the CreateComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentCommentID *string, authorID string, text string) (*model.Comment, error) {
	intPostID, err := strconv.Atoi(postID)
	if err != nil {
		return nil, err
	}
	intAuthorID, err := strconv.Atoi(authorID)
	if err != nil {
		return nil, err
	}
	newComment, err := r.CommentsService.CreateComment(models.Comment{
		PostID:          intPostID,
		ParentCommentID: parentCommentID,
		AuthorId:        intAuthorID,
		Text:            text,
	})
	if err != nil {
		return nil, err
	}

	mappedComment := model.Comment{
		AuthorID:        strconv.Itoa(newComment.AuthorId),
		ID:              strconv.Itoa(newComment.ID),
		Text:            newComment.Text,
		PostID:          strconv.Itoa(newComment.PostID),
		ParentCommentID: newComment.ParentCommentID,
	}
	// ПОД ВОПРОСОМ
	errNotify := r.CommentsObservers.NotifyObservers(intPostID, newComment)
	if errNotify != nil {
		return nil, fmt.Errorf("failed to notify observers: %w", err)
	}
	return &mappedComment, nil
}

// GetAllPosts is the resolver for the GetAllPosts field.
func (r *queryResolver) GetAllPosts(ctx context.Context, page *int, pageSize *int) ([]*model.Post, error) {
	if page == nil || pageSize == nil {
		return nil, errors.New("page and pageSize must be provided")
	}

	posts, err := r.PostsService.GetAllPosts(page, pageSize)
	if err != nil {
		return nil, err
	}

	res := make([]*model.Post, 0, len(posts))
	for _, post := range posts {
		res = append(res, &model.Post{
			ID:            strconv.Itoa(post.ID),
			Title:         post.Title,
			Content:       post.Content,
			AuthorID:      strconv.Itoa(post.AuthorId),
			AllowComments: post.AllowComments,
		})
	}

	return res, nil
}

// GetPostByID is the resolver for the GetPostById field.
func (r *queryResolver) GetPostByID(ctx context.Context, id int) (*model.Post, error) {
	post, err := r.PostsService.GetPostById(id)
	if err != nil {
		return nil, err
	}
	page := 1
	pageSize := 10
	comments, err := r.CommentsService.GetCommentsByPost(id, &page, &pageSize)
	if err != nil {
		return nil, err
	}
	mappedComments := make([]*model.Comment, 0, len(comments))
	for _, comment := range comments {
		mappedComments = append(mappedComments, &model.Comment{
			AuthorID:        strconv.Itoa(comment.AuthorId),
			ID:              strconv.Itoa(comment.ID),
			Text:            comment.Text,
			PostID:          strconv.Itoa(comment.PostID),
			ParentCommentID: comment.ParentCommentID,
		})
	}

	mappedPost := model.Post{
		ID:            strconv.Itoa(post.ID),
		Title:         post.Title,
		Content:       post.Content,
		AuthorID:      strconv.Itoa(post.AuthorId),
		AllowComments: post.AllowComments,
		Comments:      mappedComments,
	}
	return &mappedPost, nil
}

// ПОД ВОПРОСОМ
func (r *subscriptionResolver) CommentsSubscription(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	intPostID, err := strconv.Atoi(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID: %w", err)
	}

	id, ch, err := r.CommentsObservers.CreateObserver(intPostID)
	if err != nil {
		return nil, fmt.Errorf("failed to create observer: %w", err)
	}

	receiveOnlyCh := make(chan *model.Comment)

	go func() {
		defer close(receiveOnlyCh)
		for {
			select {
			case <-ctx.Done():

				err := r.CommentsObservers.DeleteObserver(intPostID, id)
				if err != nil {
					log.Println("Error deleting observer:", err)
				}
				return
			case comment, ok := <-ch:
				if !ok {
					return
				}
				receiveOnlyCh <- &model.Comment{
					ID:              strconv.Itoa(comment.ID),
					PostID:          strconv.Itoa(comment.PostID),
					ParentCommentID: comment.ParentCommentID,
					AuthorID:        strconv.Itoa(comment.AuthorId),
					Text:            comment.Text,
				}
			}
		}
	}()

	return receiveOnlyCh, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver { return &queryResolver{r} }

// Subscription returns graphql1.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graphql1.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
